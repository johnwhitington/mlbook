<!DOCTYPE html>
<!--This file is not automatically generated unlike splitxx.html -->
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title> </title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p><a href="index.html">Back to Contents</a></p>
<h1 id="starting-off">Starting Off</h1>
<p>We will cover a fair amount of material in this chapter and its
questions, since we will need a solid base on which to build. You should
read this with a computer running OCaml in front of you.</p>
<p>Consider first the mathematical expression <span class="math inline">1 + 2 × 3</span>. What is the result? How did you
work it out? We might show the process like this:</p>
<div class="center">
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIUAAABFCAMAAABT7NW6AAAAOVBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACXHtMAAAAEnRSTlMAEKtUuzJEiZnN7yJ23WblyekA31ZSAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACeklEQVRoBe1a3bqjIAwEjeAPsru8/8MuopRgCzZA7/CiB5Ek4yTyMXAYa3PxYUw6UruBLfFUZ54lTNLdI5gIBZdh7DyP0qw8dKCWUptYd9RR15xuKOaXOwdIG/3qwI0Duja4p6qdRjE5v0ad7qcL3hC4UVAVGRunUbhR3IhrtHa5GvwtYxwBwh5L2g8oxpB7ZWGEUuZyNSF7JZGxzQOK5cyLs5BqxkUy7XFJYa/UdkAxg72W9fgFH1uGBFjH+xB7b0dGQOEi8IjlMfqKpQoJcYMhGhwjpN3lUAgHws9bcV0cUSACSYsbj86gEDDay38J5zcCZ4q4tDkTzagQYC7HJziUkcm466oFP1+Amy84mEFFNRO/W+UdQlHpqcrcV0GVk27cGegMdAY6A52BzsAbA9vvVhEoVk6nWvm16KCCkFXjZk6nMn5fdH8XvIC9zLqT7ct3YW+jJqS4b49StxkUs/GyJGWc6KevSDMozKoBsBr7ENRJKSek4M/f86/9JYu2NAphlonrMv2lB9r6NY1idG80mKKPRPgdhw/8fegKKO46VbhNA/3aOvhgnOxqx8XmtnFEvkRRXfxDdfFQTW/oAxfuEVZF+6EAS7aNFBUEy6AQxpYYXDtKb/DTHfT5IqNTrRwGKcmvZc3SAL98gjPypckvhtG+818g6D47A52BzkBnoDPQGShlYHEb7mupeRu7CfRx9tDshOFERV1rnacsC9XsgQL6utM63JonhK5TGVO3M7mHN40fIz1So1MZW5qdfgWAVG3GeLvT8oCCEXVqXUJQ3KhJ5qIuIaguanTqLxJC16kN/33B56RgvlgKhKgPl/jbeBJMREHd/wHaqA7xfVhi3gAAAABJRU5ErkJggg==" alt="image"></p>
</div>
<p>How did we know to multiply <span class="math inline">2</span> by
<span class="math inline">3</span> first, instead of adding <span class="math inline">1</span> and <span class="math inline">2</span>? How
did we know when to stop? Let us underline the part of the expression
which is dealt with at each step:</p>
<div class="center">
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIYAAABFCAMAAAC42265AAAAOVBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACXHtMAAAAEnRSTlMAEKtUuzJEiZnN7yJ23WblyekA31ZSAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACiUlEQVRoBe1a2XaEIAwFRRBF2vL/H1sEGQJTsCz2oQcfHLYklyRSLhShPg+e5qQicSiyJ3plpi8hkmmeiQpgYOYHr+vM1IZ9AygJsdPtAA2NxSWCsb70GURSyVcDLJzYpYItbeU0jMUoVsLqXy58k/eOIG2moXQahhmFFb1GSxOuyVURwgAR1FhVvoEx+/gLjcPnM2ab8gGsMg2FbmBwGxojwcQKE2U5wrSCWovLHsZK9MO3802cceZjoDUfU6i+ozs8DGMCB46eg4+ZCR8TM5gEg0OIhbUcDGpQuAUszI3TDAlQFhoOh2dgUDLrx30P9kshNkqY6bDRfs6gRF2aLToQlEWZ58oHt24Qs25goiYR5E04udYagNGqqkneZUKTkn8obFPj5v0P5z2mNDwwPDA8MDzwlAf2B3cVAHOOw2pixqWnR0CqdzHHYRGOt+K/tF7hwMxeFB38l3ajYQvg41FXqpqBsSpHV1LCqfbybWoGhtokIZCn/WTVkCxDscjHp/3V72I+l4ZBFV+wrGRmcirb1KZhzGZKk6r7VKg7kfjJhe9tHkbMYak5U5Cvk4V32UxLP2/s5qCH3uQpyI0vkBt3KRXPwHvD9EC6dJzksOpkSZSiQBkYVOk0I9ehUww/Vy9fNzIcVnNlwljxvDS+ilU0mhUMStT1p9Wyz/1PoT1t7IagXt1Poxj6hweGB4YHhgeGB/p5gJu/Xls/hVWaFiLPq4p+FxIWRenuy17L8FKxuymX70W1xr1/TMo5LEIiusi7m2vYD3hKC4dFiPe7MfMIS1kbwh1v2j0MVMhhG2MCDAfFYm80xgTkRguHfSQm5Ry2538/uLBUrBu8hqQ6e4nf3sthwgxo/gbdgBQ3GAgfIQAAAABJRU5ErkJggg==" alt="image"></p>
</div>
<p>We chose which part of the expression to deal with each time using a
familiar mathematical rule – multiplication is done before addition. We
stopped when the expression could not be processed any further.</p>
<p>Computer programs in OCaml are just like these expressions. In order
to give you an answer, the computer needs to know all the rules you know
about how to process the expression correctly. In fact, <span class="math inline">1 + 2 × 3</span> is a valid OCaml expression as well
as a valid mathematical one, but we must write <code>*</code> instead of
<span class="math inline">×</span>, since there is no <span class="math inline">×</span> key on the keyboard:</p>
<p><code>        OCaml</code><br>
<br>
<code># 1 + 2 * 3;;</code><br>
<code>- : int = 7</code></p>
<p>Here, <code>#</code> is OCaml prompting us to write an expression,
and <code>1 + 2 * 3;;</code> is what we typed (the semicolons followed
by the Enter key tell OCaml we have finished our expression). OCaml
responds with the answer <code>7</code>. OCaml also prints
<code>int</code>, which tells us that the answer is a whole number, or
<em>integer</em>.</p>
<p>Let us look at our example expression some more. There are two
<em>operators</em>: <span class="math inline">+</span> and <span class="math inline">×</span>. There are three <em>operands</em>: <span class="math inline">1</span>, <span class="math inline">2</span>, and
<span class="math inline">3</span>. When we wrote it down, and when we
typed it into OCaml, we put spaces between the operators and operands
for readability. How does OCaml process it? Firstly, the text we wrote
must be split up into its basic parts: <code>1</code>, <code>+</code>,
<code>2</code>, <code>*</code>, and <code>3</code>. OCaml then looks at
the order and kind of the operators and operands, and decides how to
parenthesize the expression: <span class="math inline">(1+(2×3))</span>.
Now, processing the expression just requires dealing with each
parenthesized section, starting with the innermost, and stopping when
there are no parentheses left:</p>
<div class="center">
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKMAAABKCAMAAADg+RT4AAAAOVBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACXHtMAAAAEnRSTlMAiZkyVHbdRO8iEM27q2blyelzEvSJAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAD00lEQVRoBe1aa5ejIAzFBz4Q2V3+/49dGhLAFiwZ6Zk5c+yHxuIlXJKIcq0QrT5djaMqkHMklfdGtsb3e0w/vMeIKhD42dEb2QrnbyGj9BC1j2WsB8nJ6rUAMnRu6D2CbAHPap48etQ25aiOuQVQ34+dXTCXT2NIuc6Ld7XhNMg+Ib/wc8Zpi+HIkZrBJYCAtrEmO8hjfsbCKYPTI5vFsxp7it4ZRwD5srVYGpTKPcZVahh5XTwBsiw6WfBCBXbGMYCEsjO68WHa6acQiugSmmx2XE6jz4/rccYxgMSI5es6SJfTeJ2pbrFYHxMuFGQ5dHJYFYY/4RhBYksWqk72aXEOE1b0huVDNjcup2195dhr99mWx7f2jCKoi6l1o0xPayAGUiNHshw+WewrR4Cpw3VNoJEuMMB0MqYaGrTvtOFEyGbH5TRaui5Pci0QNANFusiO9fgYEwM3IYIsh04WGyZ7xtGDZj26D129/rrWPmaqc1VBSy2uPYJsdlxOo8T1btYWx4Pex1wDaLDwwRqk9VFDHpS2u8QUE1WyHDZ5rIqLSQo4ciyA0g7xuEeuZOOZLx8VXFHVeb8FUG5QtflWsjkMt035O9h5tyqQd0FPcWTPHVeeXY+POPleVaBHV4PLE9m8O3brMa2F7lUg15dwZAvu7uYfGQG/LDK/f+RMblJ3BO4I3BG4I/AtEah57vHE2gp2jMnWPeit8HT9tFlljHIJWqXtmc3AvoV2MZdG5HfG/cyZtqfiZr+BYIfbHQbTsHs72btOuEVxbhsIdkN9/eM8KrS93kaRp4VgR5vc6kgGAa4cR7sYrUl9CviqEUA7AuVI//nrrfs+qLEVfkjKKWt7s90GZZ6FuwrXZYjZOdudKNsV4zjCtHfUfNoIdjPJweV5xDNRtgscn7W9GaRbgwJuE8GOF0fxPtcryPQzXjhBw4rzPDlK6vFfUo9U3Cc901MV2t70kBXxpYFoINhJJkUR4hJyDTNINanZugrXqK9dF+z462ONtjfrrsO5hyU/zQXvmH+fKch2aRxTCgwBLe128bgwan4BaynYMXgzZDvBeP3KYFABrZbtonBX4bUxJJ/W3CD1yFzvX9zGVMMQ/osDck/tjsAdgTsCdwTaRmCDW8f1h+u2rA7eBm0er/YPf544AD7wg/sc7l+Shj3NBxi9uuTvZ5yPFhrOK5VyC1vvca7k55TPZH99Qe9xHNvII+W4vZ5h6hTuv2xBqnh19qkWlt7jSHww1aUpsuP4yVQn9XhB7/mGVLP1HoH//iylpX37F9bHjatiXWXNvc9cHe9N//9xCCBL9it1WwAAAABJRU5ErkJggg==" alt="image"></p>
</div>
<p>OCaml knows that <span class="math inline">×</span> is to be done
before <span class="math inline">+</span>, and parenthesizes the
expression appropriately. We say the <span class="math inline">×</span>
operator has <em>higher precedence</em> than the <span class="math inline">+</span> operator.</p>
<p>An <em>expression</em> is any valid OCaml program. To produce an
answer, OCaml <em>evaluates</em> the expression, yielding a special kind
of expression, a <em>value</em>. In our previous example, <span class="math inline">1 + 2 × 3</span>, <span class="math inline">1 + 6</span>, and <span class="math inline">7</span>
were all expressions, but only <span class="math inline">7</span> was a
value.</p>
<p>Each expression (and so each value) has a <em>type</em>. The type of
<span class="math inline">7</span> is <span class="sans-serif"><strong>int</strong></span> (it is an integer). The
types of the expressions <span class="math inline">1 + 6</span> and
<span class="math inline">1 + 2 × 3</span> are also <span class="sans-serif"><strong>int</strong></span>, since they will evaluate
to a value of type <span class="sans-serif"><strong>int</strong></span>.
The type of any expression may be worked out by considering the types of
its sub-expressions, and how they are combined to form the expression.
For example, <span class="math inline">1 + 6</span> has type <span class="sans-serif"><strong>int</strong></span> because <span class="math inline">1</span> is an <span class="sans-serif"><strong>int</strong></span>, <span class="math inline">6</span> is an <span class="sans-serif"><strong>int</strong></span>, and the <span class="math inline">+</span> operator takes two integers and gives
another one (their sum). Here are the mathematical operators on
integers:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Operator</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><em>a</em> <code>+</code> <em>b</em></td>
<td style="text-align: left;">addition</td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>a</em> <code>-</code> <em>b</em></td>
<td style="text-align: left;">subtract <em>b</em> from <em>a</em></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><em>a</em> <code>*</code> <em>b</em></td>
<td style="text-align: left;">multiplication</td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>a</em> <code>/</code> <em>b</em></td>
<td style="text-align: left;">divide <em>a</em> by <em>b</em>, returning
the whole part</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><em>a</em> <code>mod</code>
<em>b</em></td>
<td style="text-align: left;">divide <em>a</em> by <em>b</em>, returning
the remainder</td>
</tr>
</tbody>
</table>
<p>The <code>mod</code>, <code>*</code>, and <code>/</code> operators
have higher precedence than the <code>+</code> and <code>-</code>
operators. For any operator <span class="math inline">⊕</span> above,
the expression <span class="math inline"><em>a</em> ⊕ <em>b</em> ⊕ <em>c</em></span> is
equivalent to <span class="math inline">(<em>a</em>&nbsp;⊕&nbsp;<em>b</em>) ⊕ <em>c</em></span> rather
than <span class="math inline"><em>a</em> ⊕ (<em>b</em>&nbsp;⊕&nbsp;<em>c</em>)</span> (we
say the operators are <em>left associative</em>). We sometimes write
down the type of an expression after a colon when working on paper, to
keep it in mind:</p>
<p><code>5 * -2 :</code> <strong><span class="sans-serif">int</span></strong></p>
<p>(negative numbers are written with <code>-</code> before them). Of
course, there are many more types than just <span class="sans-serif"><strong>int</strong></span>. Sometimes, instead of
numbers, we would like to talk about truth: either something is true or
it is not. For this we use the type <span class="sans-serif"><strong>bool</strong></span> which represents
<em>boolean values</em>, named after the English mathematician George
Boole (1815–1864) who pioneered their use. There are just two things of
type <strong><span class="sans-serif">bool</span></strong>:</p>
<p><code>true</code><br>
<code>false</code></p>
<p>How can we use these? One way is to use one of the <em>comparison
operators</em>, which are used for comparing values to one another. For
example:</p>
<p><code>        OCaml</code><br>
<br>
<code># 99 &gt; 100;;</code><br>
<code>- : bool = false</code><br>
<code># 4 + 3 + 2 + 1 = 10;;</code><br>
<code>- : bool = true</code></p>
<p>Here are all the comparison operators:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Operator</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><em>a</em> <code>=</code> <em>b</em></td>
<td style="text-align: left;">true if <em>a</em> and <em>b</em> are
equal</td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>a</em> <code>&lt;</code>
<em>b</em></td>
<td style="text-align: left;">true if <em>a</em> is less than
<em>b</em></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><em>a</em> <code>&lt;=</code>
<em>b</em></td>
<td style="text-align: left;">true if <em>a</em> is less than or equal
to <em>b</em></td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>a</em> <code>&gt;</code>
<em>b</em></td>
<td style="text-align: left;">true if <em>a</em> is more than
<em>b</em></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><em>a</em> <code>&gt;=</code>
<em>b</em></td>
<td style="text-align: left;">true if <em>a</em> is more than or equal
to <em>b</em></td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>a</em> <code>&lt;&gt;</code>
<em>b</em></td>
<td style="text-align: left;">true if <em>a</em> is not equal to
<em>b</em></td>
</tr>
</tbody>
</table>
<p>Notice that if we try to use operators with types for which they are
not intended, OCaml will not accept the program at all, showing us where
our mistake is by underlining it:</p>
<p><code>        OCaml</code><br>
<br>
<code># 1 + </code><u><code>true</code></u><code>;;</code><br>
<code>Error:&nbsp;This expression has type bool but an expression was expected of type</code><br>
<code>         int</code></p>
<p>You can find more information about error messages in OCaml in the
appendix “Coping with Errors” at the back of this book.</p>
<p>There are two operators for combining boolean values (for instance,
those resulting from using the comparison operators). The expression
<em><span class="roman"><code>a</code></span></em><code> &amp;&amp; </code><em><span class="roman"><code>b</code></span></em> evaluates to <code>true</code>
only if expressions <em>a</em> and <em>b</em> both evaluate to
<code>true</code>. The expression <em><span class="roman"><code>a</code></span></em><code> || </code><em><span class="roman"><code>b</code></span></em> evaluates to <code>true</code>
only if <em>a</em> evaluates to <code>true</code>, <em>b</em> evaluates
to <code>true</code>, or both do. The <code>&amp;&amp;</code> operator
(pronounced “and”) is of higher precedence than the <code>||</code>
operator (pronounced “or”), so <span class="roman"><span class="upright"><code>a</code></span></span><code> &amp;&amp; </code><em><span class="roman"><code>b</code></span></em><code> || </code><span class="roman"><em><code>c</code></em></span> is the same as
<code>(</code><em><span class="roman"><code>a</code></span></em><code> &amp;&amp; </code><em><span class="roman"><code>b</code></span></em><code>) || </code><span class="roman"><em><code>c</code></em></span>.</p>
<p>A third type we shall be using is <strong><span class="sans-serif">char</span></strong> which holds a single
<em>character</em>, such as ‘a’ or ‘?’. We write these in single
quotation marks:</p>
<p><code>        OCaml</code><br>
<br>
<code># ’c’;;</code><br>
<code>- :&nbsp;char = ’c’</code></p>
<p>So far we have looked only at operators like <code>+</code>,
<code>mod</code>, and <code>=</code> which look like familiar
mathematical ones. But many constructs in programming languages look a
little different. For example, to choose a course of evaluation based on
some test, we use the <strong><code>if</code></strong>
…&nbsp;<strong><code>then</code></strong>
…&nbsp;<strong><code>else</code></strong> construct:</p>
<p><code>        OCaml</code><br>
<br>
<code># if 100 &gt; 99 then 0 else 1;;</code><br>
<code>- :&nbsp;int = 0</code></p>
<p>The expression between <strong><code>if</code></strong> and
<strong><code>then</code></strong> (in our example
<code>100 &gt; 99</code>) must have type <strong><span class="sans-serif">bool</span></strong> – it evaluates to either
<code>true</code> or <code>false</code>. The types of the expression to
choose if true and the expression to choose if false must be the same as
one another – here they are both of type <strong><span class="sans-serif">int</span></strong>. The whole expression evaluates
to the same type – <strong><span class="sans-serif">int</span></strong>
– because either the <strong><code>then</code></strong> part or the
<strong><code>else</code></strong> part is chosen to be the result of
evaluating the whole expression:</p>
<div class="center">
<p><img src="data:image/png;base64,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" alt="image"></p>
</div>
<p>We have covered a lot in this chapter, but we need all these basic
tools before we can write interesting programs. Make sure you work
through the questions on paper, on the computer, or both, before moving
on. Hints and answers are at the back of the book.</p>
<h2 class="unnumbered" id="questions">Questions</h2>
<ol>
<li><p>What are the types of the following expressions and what do they
evaluate to, and why?</p>
<p><code>17</code></p>
<p><code>1 + 2 * 3 + 4</code></p>
<p><code>800 / 80 / 8</code></p>
<p><code>400 &gt; 200</code></p>
<p><code>1 &lt;&gt; 1</code></p>
<p><code>true || false</code></p>
<p><code>true &amp;&amp; false</code></p>
<p><strong><code>if</code></strong><code> true </code><strong><code>then</code></strong><code> false </code><strong><code>else</code></strong><code> true</code></p>
<p><code>’%’</code></p>
<p><code>’a’ + ’b’</code></p></li>
<li><p>Consider the evaluations of the expressions
<code>1 + 2 mod 3</code>, <code>(1 + 2) mod 3</code>, and
<code>1 + (2 mod 3)</code>. What can you conclude about the
<code>+</code> and <code>mod</code> operators?</p></li>
<li><p>A programmer writes <code>1+2 * 3+4</code>. What does this
evaluate to? What advice would you give him?</p></li>
<li><p>The range of numbers available is limited. There are two special
numbers: <code>min_int</code> and <code>max_int</code>. What are their
values on your computer? What happens when you evaluate the expressions
<code>max_int + 1</code> and <code>min_int - 1</code>?</p></li>
<li><p>What happens when you try to evaluate the expression
<code>1 / 0</code>? Why?</p></li>
<li><p>Can you discover what the <code>mod</code> operator does when one
or both of the operands are negative? What about if the first operand is
zero? What if the second is zero?</p></li>
<li><p>Why not just use, for example, the integer <code>0</code> to
represent false and the integer <code>1</code> for true? Why have a
separate <strong><span class="sans-serif">bool</span></strong> type at
all?</p></li>
<li><p>What is the effect of the comparison operators like
<code>&lt;</code> and <code>&gt;</code> on alphabetic values of type
<strong><span class="sans-serif">char</span></strong>? For example, what
does <code>’p’ &lt; ’q’</code> evaluate to? What is the effect of the
comparison operators on the booleans, <code>true</code> and
<code>false</code>?</p></li>
</ol>
<!--This file is not automatically generated unlike splitxx.html -->
</body>
</html>
