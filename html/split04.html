<!DOCTYPE html>
<!--This file is not automatically generated unlike splitxx.html -->
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title> </title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p><a href="index.html">Back to Contents</a></p>
<h1 id="names-and-functions">Names and Functions</h1>
<p>So far we have built only tiny toy programs. To build bigger ones, we
need to be able to name things so as to refer to them later. We also
need to write expressions whose result depends upon one or more other
things.</p>
<p>Before, if we wished to use a sub-expression twice or more in a
single expression, we had to type it multiple times:</p>
<p><code>        OCaml</code><br>
<br>
<code># 200 * 200 * 200;;</code><br>
<code>- : int = 8000000</code></p>
<p>Instead, we can define our own name to stand for the result of
evaluating an expression, and then use the name as we please:</p>
<p><code>        OCaml</code><br>
<br>
<code># let x = 200;;</code><br>
<code>val x : int = 200</code><br>
<code># x * x * x;;</code><br>
<code>- : int = 8000000</code></p>
<p>To write this all in a single expression, we can use the
<strong><code>let</code></strong>
&nbsp;…&nbsp;&nbsp;<code>=</code>&nbsp;&nbsp;…&nbsp;<strong><code>in</code></strong> &nbsp;construct:</p>
<p><code>        OCaml</code><br>
<br>
<code># let x = 200 in x * x * x;;</code><br>
<code>- : int = 8000000</code><br>
<code># let a = 500 in (let b = a * a in a + b);;</code><br>
<code>- : int = 250500</code></p>
<p>We can also make a <em>function</em>, whose value depends upon some
input (we call this input an <em>argument</em> – we will be using the
word “input” later in the book to mean something different):</p>
<p><code>        OCaml</code><br>
<br>
<code># let cube x = x * x * x;;</code><br>
<code>val cube : int -&gt; int = &lt;fun&gt;</code><br>
<code># cube 200;;</code><br>
<code>- : int = 8000000</code></p>
<p>We chose <code>cube</code> for the name of the function and
<code>x</code> for the name of its argument. When we typed the function
in, OCaml replied by telling us that its type is <span class="sans-serif"><strong>int</strong> <span class="math inline">→</span> <strong>int</strong></span>. This means it
is a function which takes an integer as its argument, and, when given
that argument, evaluates to an integer. To use the function, we just
write its name followed by a suitable argument. In our example, we
calculated <span class="math inline">200<sup>3</sup></span> by giving
the <code>cube</code> function <code>200</code> as its argument.</p>
<p>The <code>cube</code> function has type <span class="sans-serif"><strong>int</strong> <span class="math inline">→</span> <strong>int</strong></span>, we gave it an
integer <code>200</code>, and so the result is another integer. Thus,
the type of the expression <code>cube 200</code> is <strong><span class="sans-serif">int</span></strong> – remember that the type of any
expression is the type of the thing it will evaluate to, and
<code>cube 200</code> evaluates to <code>8000000</code>, an integer. In
diagram form:</p>
<div class="center">
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG4AAABICAMAAAAgcDDiAAAANlBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABHL6OuAAAAEXRSTlMAid0Qme9EzasiMna7VGbX8Q7UKmAAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAO1SURBVFgJ7Vnr0pwgDEUQEQG/8v4v2ySACCsuunbamS4/Vi7nJDEgJAtjjA1cwO/b0gPrwYxyr86phuIeWA+mFK9k2W60emANDL2cZoyeXOr9y07QH8sZrB8zKS/YorzxfmbMwe+SyPAUQ2ycwwKoB8NmUMesnzTHiuI7ZVBdXWyfwwKoBzOgltkzNnrwXFAnhq3wMYg6gkVLtsclzEDqqqWiR5oz+F6SVYewyqQTDL2UhbcLGL9E+UECzGco57BuzMRhiTjpB1CHa0UWX/20Rm3nsADqwURxjUfxpg3Mt/sf9MBPa7s+t/UmbZAybWHn8svRezQN+9rkbd6iS6GtVh9N+KJMq/VyYmzyXplJF2OwIZQlc1u0Eu9sKY9alj45cTiUtm0QU3OPaTYzFv6qjI/bKbSMR+NxuOKe0Hhk4AnnLs2QdrP3ZG4vNzNgNdzYqMTsaWb7uYEhbq11mDMjxUUuMNhqy1XT35rXq9w5nS79Sr7IDzwgLn0iHygKVFNFSi2BelQ8bR2jsnFR5FqLV/X3qrNyNBbiHShKmtGbslZJbTZ71dEWheEcxOGwAYxlrSF+slLOsMk4/Bo1Hj5GToq6IH6feaw12MxgoDqj+yfc5HLtmGD86JwF4wwat3gw2Xi5Oo6BvJDKuTqkL+VgKM44mirQm7lWwmJL+BifF+rAzAVtHdFq4U92Bk0zJmemDMNpzLVDdQ5fh8r+7bBDgh1y1lBSxhBwxa/gFNqAwyE8RstzrcClhsEsgEqtjkN4HQ/FLYhPrO2pQvgNLhSbM2Ntw+wrDmeaCqmbwtxhB73dmzDJxmCfplej03MtSK1+g++xc8U5X4M6cDDNmD2PAq2MtpKPqp9KUWzOsCTECvIXPwiIC2hlKgEnI3h58ZB66QHW7VGBD9tBAZyA83qRYXmm2hED+kaYILISKpxWjpGQRGNMBt+ShNEUctQCYjyDwAVw4RTNtRqe2jq6ZL81pxllokz9Euflmf9MyLUX0Lfj64H/1wNre8t93CkYwdwN2q8bM4Rj/nKCel0TMDCrReJhgvqa8cWeUlXOW5sEGkhZLbIPE9QmPQWTr3lrk0IDu9TsMEFtssOhUOWtTTQN7LLa0j3vWikP7c1b38l7P4556L2c973sQ4T59etN4HJIu92pfm5Tv8S/5oGeS6UHjbt+qfSg8sal0oMaKGuByJOe1f3Ug2qCqK5LpQe19lwqPahuuwna3U89KL4Wtak7uVSqOR+0ey6ePhBfUT+/VKoE/tHmb87aQHPscabyAAAAAElFTkSuQmCC" alt="image"></p>
</div>
<p>If we try an argument of the wrong type, the program will be
rejected:</p>
<p><code>        OCaml</code><br>
<br>
<code># let cube x = x * x * x;;</code><br>
<code>val cube : int -&gt; int = &lt;fun&gt;</code><br>
<code># cube</code> <u><code>false</code></u><code>;;</code><br>
<code>Error: This expression has type bool but an expression was expected of type</code><br>
<code>         int</code></p>
<p>Here is a function which determines if an integer is negative:</p>
<p><code>        OCaml</code><br>
<br>
<code># let neg x = if x &lt; 0 then true else false;;</code><br>
<code>val neg : int -&gt; bool = &lt;fun&gt;</code><br>
<code># neg (-30);;</code><br>
<code>- : bool = true</code></p>
<p>(We added parentheses to distinguish from <code>neg - 30</code>).
But, of course, this is equivalent to just writing</p>
<p><code>        OCaml</code><br>
<br>
<code># let neg x = x &lt; 0;;</code><br>
<code>val neg : int -&gt; bool = &lt;fun&gt;</code><br>
<code># neg (-30);;</code><br>
<code>- : bool = true</code></p>
<p>because <code>x &lt; 0</code> will evaluate to the appropriate
boolean value on its own – <code>true</code> if <span class="math inline"><code>x</code> &lt; 0</span> and <code>false</code>
otherwise. Here is another function, this time of type <strong><span class="sans-serif">char <span class="math inline">→</span>
bool</span></strong>. It determines if a given character is a vowel or
not:</p>
<p><code>        OCaml</code><br>
<br>
<code># let isvowel c =</code><br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;c = ’a’ || c = ’e’ || c = ’i’ || c = ’o’ || c = ’u’;;</code><br>
<code>val isvowel : char -&gt; bool = &lt;fun&gt;</code><br>
<code># isvowel ’x’;;</code><br>
<code>- : bool = false</code></p>
<p>Notice that we typed the function over two lines. This can be done by
pressing the Enter key in between lines. OCaml knows that we are
finished when we type <code>;;</code> followed by Enter as usual. Notice
also that we pressed space a few times so that the second line appeared
a little to the right of the first. This is known as
<em>indentation</em> and does not affect the meaning of the program at
all – it is just for readability.</p>
<p>There can be more than one argument to a function. For example, here
is a function which checks if two numbers add up to ten:</p>
<p><code>        OCaml</code><br>
<br>
<code># let addtoten a b =</code><br>
<code>    a + b = 10;;</code><br>
<code>val addtoten : int -&gt; int -&gt; bool = &lt;fun&gt;</code><br>
<code># addtoten 6 4;;</code><br>
<code>- : bool = true</code></p>
<p>The type is <span class="sans-serif"><strong>int <span class="math inline">→</span> int <span class="math inline">→</span>
bool</strong></span> because the arguments are both integers, and the
result is a boolean. We use the function in the same way as before, but
writing two integers this time, one for each argument the function
expects.</p>
<p>A <em>recursive</em> function is one which uses itself. Consider
calculating the factorial of a given number – the factorial of 4
(written <span class="math inline">4!</span> in mathematics), for
example, is <span class="math inline">4 × 3 × 2 × 1</span>. Here is a
recursive function to calculate the factorial of a positive number. Note
that it uses itself in its own definition.</p>
<p><code>        OCaml</code><br>
<br>
<code># let rec factorial a =</code><br>
<code>    if a = 1 then 1 else a * factorial (a - 1);;</code><br>
<code>val factorial : int -&gt; int = &lt;fun&gt;</code><br>
<code># factorial 4;;</code><br>
<code>- : int = 24</code></p>
<p>We used <strong><code>let rec</code></strong> instead of
<strong><code>let</code></strong> to indicate a recursive function. How
does the evaluation of <code>factorial 4</code> proceed?</p>
<div class="center">
<p><img src="data:image/png;base64,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" alt="image"></p>
</div>
<p>For the first three steps, the <strong><code>else</code></strong>
part of the conditional expression is chosen, because the argument
<code>a</code> is greater than one. When the argument is equal to one,
we do not use <code>factorial</code> again, but just evaluate to one.
The expression built up of all the multiplications is then evaluated
until a value is reached: this is the result of the whole evaluation. It
is sometimes possible for a recursive function never to finish – what if
we try to evaluate <code>factorial (-1)</code>?</p>
<div class="center">
<p><img src="data:image/png;base64,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" alt="image"></p>
</div>
<p>The expression keeps expanding, and the recursion keeps going.
Helpfully, OCaml tells us what is going on:</p>
<p><code>        OCaml</code><br>
<br>
<code># let rec factorial a =</code><br>
<code>    if a = 1 then 1 else a * factorial (a - 1);;</code><br>
<code>val factorial : int -&gt; int = &lt;fun&gt;</code><br>
<code># factorial (-1);;</code><br>
<code>Stack overflow during evaluation (looping recursion?).</code></p>
<p>This is an example of an error OCaml cannot find by merely looking at
the program – it can only be detected during evaluation. Later in the
book, we will see how to prevent people who are using our functions from
making such mistakes.</p>
<p>One of the oldest methods for solving a problem (or
<em>algorithm</em>) still in common use is Euclid’s algorithm for
calculating the greatest common divisor of two numbers (that is, given
two positive integers <span class="math inline"><em>a</em></span> and
<span class="math inline"><em>b</em></span>, finding the biggest
positive integer <span class="math inline"><em>c</em></span> such that
neither <span class="math inline"><em>a</em>/<em>c</em></span> nor <span class="math inline"><em>b</em>/<em>c</em></span> have a remainder).
Euclid was a Greek mathematician who lived about three centuries before
Christ. Euclid’s algorithm is simple to write as a function with two
arguments:</p>
<p><code>        OCaml</code><br>
<br>
<code># let rec gcd a b =</code><br>
<code>    if b = 0 then a else gcd b (a mod b);;</code><br>
<code>val gcd : int -&gt; int -&gt; int = &lt;fun&gt;</code><br>
<code># gcd 64000 3456;;</code><br>
<code>- : int = 128</code></p>
<p>Here is the evaluation:</p>
<div class="center">
<p><img src="data:image/png;base64,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" alt="image"></p>
</div>
<p>Finally, here is a simple function on boolean values. In the previous
chapter, we looked at the <code>&amp;&amp;</code> and <code>||</code>
operators which are built in to OCaml. The other important boolean
operator is the <code>not</code> function, which returns the boolean
complement (opposite) of its argument – <code>true</code> if the
argument is <code>false</code>, and vice versa. This is also built in,
but it is easy enough to define ourselves, as a function of type <span class="sans-serif"><strong>bool <span class="math inline">→</span>
bool</strong></span>.</p>
<p><code>        OCaml</code><br>
<br>
<code># let not x =</code><br>
<code>    if x then false else true;;</code><br>
<code>val not : bool -&gt; bool = &lt;fun&gt;</code><br>
<code># not true;;</code><br>
<code>- : bool = false</code></p>
<p>Almost every program we write will involve functions such as these,
and many larger ones too. In fact, languages like OCaml are often called
<em>functional languages</em>.</p>
<h2 class="unnumbered" id="questions-1">Questions</h2>
<ol>
<li><p>Write a function which multiplies a given number by ten. What is
its type?</p></li>
<li><p>Write a function which returns <code>true</code> if both of its
arguments are non-zero, and <code>false</code> otherwise. What is the
type of your function?</p></li>
<li><p>Write a recursive function which, given a number <span class="math inline"><em>n</em></span>, calculates the sum <span class="math inline">1 + 2 + 3 + … + <em>n</em></span>. What is its
type?</p></li>
<li><p>Write a function <code>power x n</code> which raises
<code>x</code> to the power <code>n</code>. Give its type.</p></li>
<li><p>Write a function <code>isconsonant</code> which, given a
lower-case character in the range <code>’a’</code>…<code>’z’</code>,
determines if it is a consonant.</p></li>
<li><p>What is the result of the expression 
<strong><code>let</code></strong><code> x = 1 </code><strong><code>in</code></strong>
<strong><code>let</code></strong><code> x = 2 </code><strong><code>in</code></strong><code> x + x</code>
?</p></li>
<li><p>Can you suggest a way of preventing the non-termination of the
<code>factorial</code> function in the case of a zero or negative
argument?</p></li>
</ol>
<!--This file is not automatically generated unlike splitxx.html -->
</body>
</html>
